a=5
#b=6
c=a*b
a=5
a=5
#b=6
# c=a*b
# d=a*b
# print(c)
# print(d)
#ssssssss
b=25:524
b
b
b[82]
b[83]
b[1]
b[34]
seq(4,23,3)
p<-rep(b,2)
p
d=5,7,11,18,21,28,39
d=c(5,7,11,18,21,28,39)
d
d=c(5,7,11,18,21,28,39,48,65,78,80,101)
d
d[5]
e=d[c(3,7,11)]
e
f=c(d[2],d[3])
f
d[-8]
d[-8]
f=d[c(-1,-5,-9)]
f
d>50
d[d>50]
g=d[d<80&d>30]
g
which(d>50)
length(d)
sort(d)
sort(d,decreasing = T)
d
sum(d)
min(d)
max(d)
mean(d)
sd(d)
d[12]=100
d
d[d>15]=0
d
d
m
a=5
class(a)
b=7L
class(b)
w=<-5>2
> w<-5>2
w<-5>2
w
class(w)
r='5'
class(r)
c=3+5i
class(c)
n=4+5b
c=3+5i
j=as.character(c)
j=as.complex(j)
class(j)
install.packages("ggplot2")
install.packages("ggplot2")
q()
library(shiny)
library(e1071)  # Load e1071 library for SVM
# Load your trained SVM model
load("svm_model.RData")  # Make sure the path is correct
# Define UI
ui <- fluidPage(
titlePanel("Rice Yield Prediction"),
sidebarLayout(
sidebarPanel(
# Input fields for the features
numericInput("avg_rain", "Average Rainfall", value = 50),
numericInput("Nitrogen", "Nitrogen", value = 50000),
numericInput("POTASH", "Potash", value = 10000),
numericInput("PHOSPHATE", "Phosphate", value = 20000),
numericInput("ANNUAL", "Annual Rainfall", value = 1000), # Add this line
# Add more input fields as needed
actionButton("predictButton", "Predict")
),
mainPanel(
# Display the prediction result
h3("Predicted Rice Yield:"),
verbatimTextOutput("prediction")
)
)
)
# Define server logic
server <- function(input, output) {
# Function to make predictions using the SVM model
predict_yield <- function(avg_rain, Nitrogen, POTASH, PHOSPHATE, ANNUAL, ...) {
# Create a data frame with input values
new_data <- data.frame(
avg_rain = avg_rain,
Nitrogen = Nitrogen,
POTASH = POTASH,
PHOSPHATE = PHOSPHATE,
ANNUAL = ANNUAL
# Add more input variables as needed
)
# Make predictions using the SVM model
prediction <- predict(svm_model, newdata = new_data)
return(prediction)
}
# React to button click to make predictions
observeEvent(input$predictButton, {
# Call the predict_yield function with input values
predicted_yield <- predict_yield(
input$avg_rain, input$Nitrogen, input$POTASH, input$PHOSPHATE, input$ANNUAL
# Pass more input values as needed
)
# Update the output with the predicted yield
output$prediction <- renderText({
predicted_yield
})
})
}
# Run the application
shinyApp(ui = ui, server = server)
setwd("C:/Users/sumit/OneDrive/Desktop/Data Science Practical/CP")
library(shiny)
library(e1071)  # Load e1071 library for SVM
# Load your trained SVM model
load("svm_model.RData")  # Make sure the path is correct
library(randomForest)
library(Metrics)
data1 <- read.csv("X1.csv", header = TRUE)
# Remove columns where all values are zero
data_filtered <- data[, colSums(data != 0) > 0]
y_data <- read.csv("y1.csv")
data <- cbind(data_filtered, y_data)
set.seed(123)
source("C:/Users/sumit/OneDrive/Desktop/Data Science Practical/CP/Data Cleaning.R")
View(data_filtered)
library(shiny)
# Define UI
ui <- fluidPage(
titlePanel("Rice Yield Prediction"),
sidebarLayout(
sidebarPanel(
# Input fields for the features
numericInput("ANNUAL", "Annual", value = 1103.9),
numericInput("avg_rain", "Average Rainfall", value = 62.53333),
numericInput("Nitrogen", "Nitrogen", value = 52888),
numericInput("POTASH", "Potash", value = 10466),
numericInput("PHOSPHATE", "Phosphate", value = 23912),
numericInput("INCEPTISOLS", "Inceptisols", value = 0),
numericInput("LOAMY_ALFISOL", "Loamy Alfisol", value = 0.6),
numericInput("ORTHIDS", "Orthids", value = 0),
numericInput("PSAMMENTS", "Psamments", value = 0),
numericInput("SANDY_ALFISOL", "Sandy Alfisol", value = 0),
numericInput("UDOLLS_UDALFS", "Udolls Udalfs", value = 0),
numericInput("UDUPTS_UDALFS", "Udupts Udalfs", value = 0),
numericInput("USTALF_USTOLLS", "Ustalf Ustolls", value = 0.4),
numericInput("VERTIC_SOILS", "Vertic Soils", value = 0),
numericInput("VERTISOLS", "Vertisols", value = 0),
numericInput("RICE_PRODUCTION", "Rice Production", value = 984.3),
actionButton("predictButton", "Predict")
),
mainPanel(
# Display the prediction result
h3("Predicted Rice Yield:"),
verbatimTextOutput("prediction")
)
)
)
# Define server logic
server <- function(input, output) {
# Function to make predictions
predict_yield <- function(input_data) {
# Convert input data to data frame
new_data <- data.frame(t(input_data))
# Make predictions here using your model
# For example, prediction <- predict(model, newdata = new_data)
# Dummy prediction for demonstration purposes
prediction <- sum(input_data)
return(prediction)
}
# React to button click to make predictions
observeEvent(input$predictButton, {
# Gather input data
input_data <- c(
input$ANNUAL, input$avg_rain, input$Nitrogen, input$POTASH,
input$PHOSPHATE, input$INCEPTISOLS, input$LOAMY_ALFISOL, input$ORTHIDS,
input$PSAMMENTS, input$SANDY_ALFISOL, input$UDOLLS_UDALFS,
input$UDUPTS_UDALFS, input$USTALF_USTOLLS, input$VERTIC_SOILS,
input$VERTISOLS, input$RICE_PRODUCTION
)
# Call the predict_yield function with input values
predicted_yield <- predict_yield(input_data)
# Update the output with the predicted yield
output$prediction <- renderText({
predicted_yield
})
})
}
# Run the application
shinyApp(ui = ui, server = server)
runApp('shinyApp.R')
# Install xgboost package if not already installed
if (!requireNamespace("xgboost", quietly = TRUE)) {
install.packages("xgboost")
}
# Load required library
library(xgboost)
# Train XGBoost model
xgb_model <- xgboost(data = as.matrix(train_data[, -which(names(train_data) == "RICE_YIELD")]),
label = train_data$RICE_YIELD,
nrounds = 100,  # Number of boosting rounds
objective = "reg:squarederror",  # Objective for regression
eval_metric = "rmse")  # Evaluation metric
xgb_mse <- mse(xgb_predictions, test_data$RICE_YIELD)
xgb_rmse <- rmse(xgb_predictions, test_data$RICE_YIELD)
xgb_r_squared <- cor(xgb_predictions, test_data$RICE_YIELD)^2
# Print performance metrics for XGBoost
print("XGBoost Performance Metrics:")
print(paste("Mean Absolute Error (MAE):", xgb_mae))
print(paste("Mean Squared Error (MSE):", xgb_mse))
print(paste("Root Mean Squared Error (RMSE):", xgb_rmse))
print(paste("R-squared:", xgb_r_squared))
library(randomForest)
library(Metrics)
data1 <- read.csv("X1.csv", header = TRUE)
# Remove columns where all values are zero
data_filtered <- data[, colSums(data != 0) > 0]
y_data <- read.csv("y1.csv")
data <- cbind(data_filtered, y_data)
set.seed(123)
train_indices <- sample(1:nrow(data), 0.8 * nrow(data))
train_data <- data[train_indices, ]
test_data <- data[-train_indices, ]
rf_model <- randomForest(RICE_YIELD ~ ., data = train_data)
# Install xgboost package if not already installed
if (!requireNamespace("xgboost", quietly = TRUE)) {
install.packages("xgboost")
}
# Load required library
library(xgboost)
# Train XGBoost model
xgb_model <- xgboost(data = as.matrix(train_data[, -which(names(train_data) == "RICE_YIELD")]),
label = train_data$RICE_YIELD,
nrounds = 100,  # Number of boosting rounds
objective = "reg:squarederror",  # Objective for regression
eval_metric = "rmse")  # Evaluation metric
# Predictions using XGBoost model
xgb_predictions <- predict(xgb_model, as.matrix(test_data[, -which(names(test_data) == "RICE_YIELD")]))
# Calculate performance metrics for XGBoost
xgb_mae <- mae(xgb_predictions, test_data$RICE_YIELD)
xgb_mse <- mse(xgb_predictions, test_data$RICE_YIELD)
xgb_rmse <- rmse(xgb_predictions, test_data$RICE_YIELD)
xgb_r_squared <- cor(xgb_predictions, test_data$RICE_YIELD)^2
# Print performance metrics for XGBoost
print("XGBoost Performance Metrics:")
print(paste("Mean Absolute Error (MAE):", xgb_mae))
print(paste("Mean Squared Error (MSE):", xgb_mse))
print(paste("Root Mean Squared Error (RMSE):", xgb_rmse))
print(paste("R-squared:", xgb_r_squared))
source("C:/Users/sumit/OneDrive/Desktop/Data Science Practical/CP/xgboost.R")
source("C:/Users/sumit/OneDrive/Desktop/Data Science Practical/CP/xgboost.R")
data1 <- read.csv("X1.csv", header = TRUE)
# Remove columns where all values are zero
data_filtered <- data[, colSums(data != 0) > 0]
y_data <- read.csv("y1.csv")
data <- cbind(data_filtered, y_data)
set.seed(123)
train_indices <- sample(1:nrow(data), 0.8 * nrow(data))
train_data <- data[train_indices, ]
test_data <- data[-train_indices, ]
source("C:/Users/sumit/OneDrive/Desktop/Data Science Practical/CP/xgboost.R")
source("C:/Users/sumit/OneDrive/Desktop/Data Science Practical/CP/xgboost.R")
source("C:/Users/sumit/OneDrive/Desktop/Data Science Practical/CP/xgboost.R")
source("C:/Users/sumit/OneDrive/Desktop/Data Science Practical/CP/Support Vector Machine.R")
source("C:/Users/sumit/OneDrive/Desktop/Data Science Practical/CP/RANDOMFOREST AFTER DATA CLEANING.R")
source("C:/Users/sumit/OneDrive/Desktop/Data Science Practical/CP/RANDOMFOREST AFTER DATA CLEANING.R")
